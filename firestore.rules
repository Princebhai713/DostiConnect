/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data is
 * nested under a user's unique ID (`/users/{userId}`), ensuring that users can only
 * access their own data or data explicitly shared with them (like friend requests
 * or chat messages). The default posture is to deny all access, granting permissions
 * explicitly and securely.
 *
 * Data Structure: All application data is organized under the top-level `/users`
 * collection. Core user-specific data like friend requests, chats, and friend
 * suggestions are stored in subcollections within each user's document.
 *
 * Key Security Decisions:
 * - User Privacy: Listing the entire `/users` collection is disallowed to prevent
 *   user enumeration and scraping. Client applications must fetch specific user
 *   profiles by their ID.
 * - Friend Requests: A friend request document is accessible only by its sender and
 *   receiver. Creation is restricted to the sender, and status updates are restricted
 *   to the receiver. This ensures clear control over the request lifecycle.
 * - Chat Security: Access to chat messages is controlled by a membership list on the
 *   parent chat document. This requires an extra document read (`get`) but provides
 *   strong, scalable security for conversations. It is assumed the parent chat
 *   document at `/users/{userId}/chats/{chatId}` contains a `participantIds` array.
 * - Read-Only Suggestions: Friend suggestions are treated as read-only for the client.
 *   This assumes they are generated by a backend process, and users can only view them.
 *
 * Denormalization for Authorization: The rules rely on denormalized fields for
 * efficient and secure authorization. `FriendRequest` and `ChatMessage` documents
 * contain `senderId` and `receiverId` fields, which are checked directly in rules,
 * avoiding complex and slow queries or lookups.
 *
 * Structural Segregation: The use of distinct subcollections for different data types
 * (e.g., `friendRequests`, `chats`) under the user's document provides clear
 * separation of concerns and allows for granular, path-based security rules. This is
 * more secure and performant than mixing data types in a single collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for concise, readable, and maintainable rules.
    
    /**
     * Returns true if a user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * This is the primary function for verifying resource ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists. Used to protect update/delete operations.
     */
    function docExists() {
      return resource != null;
    }

    /**
     * Returns true if the requesting user is the owner of an existing document.
     * Combines ownership and existence checks for state-changing operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && docExists();
    }
    
    /**
     * Validates that the user ID field in a new document matches the document's path ID.
     * Enforces relational integrity on creation.
     */
    function hasCorrectUserIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }
    
    /**
     * Validates that a user ID field is immutable on update.
     * Prevents re-assigning ownership of a document.
     */
    function userIdIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * Checks if the requesting user is a participant in a chat.
     * Assumes the parent chat document has a `participantIds` array.
     */
    function isChatParticipant(userId, chatId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participantIds;
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (get) A signed-in user fetching another user's public profile.
     * @deny (list) An anonymous user trying to list all users in the database.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isOwner(userId) && hasCorrectUserIdOnCreate(userId);
      allow update: if isExistingOwner(userId) && userIdIsImmutable();
      allow delete: if isExistingOwner(userId);
    }
    
    /**
     * @description Manages friend requests between users.
     * @path /users/{userId}/friendRequests/{friendRequestId}
     * @allow (create) A user (sender) creates a request under the receiver's user path.
     * @deny (update) The sender tries to change the status of a request they sent.
     * @principle Enforces that only the sender can create and only the receiver can accept/decline.
     */
    match /users/{userId}/friendRequests/{friendRequestId} {
      allow get: if isSignedIn() && (isOwner(resource.data.senderId) || isOwner(resource.data.receiverId));
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid && request.resource.data.receiverId == userId;
      allow update: if docExists() && isOwner(userId) && isOwner(resource.data.receiverId);
      allow delete: if docExists() && (isOwner(resource.data.senderId) || isOwner(resource.data.receiverId));
    }
    
    /**
     * @description Manages individual chat messages within a conversation.
     * @path /users/{userId}/chats/{chatId}/messages/{messageId}
     * @allow (create) A participant in a chat sends a new message.
     * @deny (get) A user who is not part of the chat tries to read a message.
     * @principle Access is granted based on membership in the parent chat document.
     */
    match /users/{userId}/chats/{chatId}/messages/{messageId} {
      allow get, list: if isChatParticipant(userId, chatId);
      allow create: if isChatParticipant(userId, chatId) && isOwner(request.resource.data.senderId);
      allow update: if docExists() && isChatParticipant(userId, chatId) && isOwner(resource.data.senderId);
      allow delete: if docExists() && isChatParticipant(userId, chatId) && isOwner(resource.data.senderId);
    }
    
    /**
     * @description Manages friend suggestions, which are private and read-only for the user.
     * @path /users/{userId}/friendSuggestions/{friendSuggestionId}
     * @allow (get, list) A user views their own list of friend suggestions.
     * @deny (create, update, delete) A user tries to create or modify their own suggestions.
     * @principle Secures server-generated data, making it read-only from the client.
     */
    match /users/{userId}/friendSuggestions/{friendSuggestionId} {
      allow get, list: if isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}